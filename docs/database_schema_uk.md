# Документація схеми бази даних GlobalScope MultiFrame 11.0

## Огляд
Цей документ надає повну документацію схеми бази даних для GlobalScope MultiFrame 11.0. Система використовує Redis як основне сховище даних зі структурою ключ-значення, організованою за типами сутностей.

## Технологія бази даних
- **Основне сховище**: Redis 7.0
- **Модель даних**: Ключ-значення з серіалізацією JSON
- **Підключення**: redis://localhost:6379 (за замовчуванням)

## Структура схеми

### Угода про іменування ключів
Усі ключі відповідають шаблону: `{entity_type}:{identifier}`

### Типи сутностей

#### 1. Користувачі
**Шаблон ключа**: `user:{user_id}`

**Поля**:
- `user_id` (рядок): Унікальний ідентифікатор користувача
- `username` (рядок): Відображуване ім'я користувача
- `email` (рядок): Електронна адреса користувача
- `role` (рядок): Роль користувача (admin, designer, engineer)
- `created_at` (часова мітка ISO): Часова мітка створення облікового запису

**Приклад**:
```json
{
  "user_id": "user_1",
  "username": "HoloMisha",
  "email": "holo@misha.com",
  "role": "admin",
  "created_at": "2025-09-29T10:30:00"
}
```

#### 2. Драйвери мікросхем
**Шаблон ключа**: `driver:{driver_id}`

**Поля**:
- `driver_id` (рядок): Унікальний ідентифікатор драйвера
- `user_id` (рядок): ID користувача, який створив драйвер
- `chip_id` (рядок): Пов'язаний ідентифікатор мікросхеми
- `chip_data` (об'єкт): Специфікації мікросхеми
  - `type` (рядок): Тип мікросхеми (quantum_processor, neural_processor, crypto_processor)
  - `cores` (ціле число): Кількість ядер
  - `frequency` (рядок): Частота обробки
  - `architecture` (рядок): Архітектура мікросхеми
- `status` (рядок): Статус драйвера (generated, optimized)
- `version` (рядок): Версія драйвера
- `timestamp` (часова мітка ISO): Часова мітка створення/модифікації

**Приклад**:
```json
{
  "driver_id": "driver_1",
  "user_id": "user_1",
  "chip_id": "chip_quantum_1",
  "chip_data": {
    "type": "quantum_processor",
    "cores": 128,
    "frequency": "4.5GHz",
    "architecture": "QubitCore"
  },
  "status": "optimized",
  "version": "2.1.0",
  "timestamp": "2025-09-29T10:30:00"
}
```

#### 3. Співпраця
**Шаблон ключа**: `collab:{collab_id}`

**Поля**:
- `collab_id` (рядок): Унікальний ідентифікатор співпраці
- `user_id` (рядок): ID творця співпраці
- `chip_id` (рядок): Пов'язаний ідентифікатор мікросхеми
- `chip_data` (об'єкт): Специфікації мікросхеми (та сама структура, що й у драйверах)
- `collaborators` (масив рядків): Список ID співавторів
- `status` (рядок): Статус співпраці (active, completed)
- `timestamp` (часова мітка ISO): Часова мітка створення

**Приклад**:
```json
{
  "collab_id": "collab_1",
  "user_id": "user_1",
  "chip_id": "chip_quantum_1",
  "chip_data": {
    "type": "quantum_processor",
    "cores": 128,
    "frequency": "4.5GHz",
    "architecture": "QubitCore"
  },
  "collaborators": ["user_2", "user_3"],
  "status": "active",
  "timestamp": "2025-09-29T10:30:00"
}
```

#### 4. Процеси мікросхем
**Шаблон ключа**: `process:{process_id}`

**Поля**:
- `process_id` (рядок): Унікальний ідентифікатор процесу
- `user_id` (рядок): ID користувача, який ініціював процес
- `chip_data` (об'єкт): Специфікації мікросхеми (та сама структура, що й у драйверах)
- `status` (рядок): Статус процесу (running, completed)
- `timestamp` (часова мітка ISO): Часова мітка створення

**Приклад**:
```json
{
  "process_id": "process_1",
  "user_id": "user_1",
  "chip_data": {
    "type": "quantum_processor",
    "cores": 128,
    "frequency": "4.5GHz",
    "architecture": "QubitCore"
  },
  "status": "completed",
  "timestamp": "2025-09-29T10:30:00"
}
```

#### 5. NFT
**Шаблон ключа**: `nft:{nft_id}`

**Поля**:
- `nft_id` (рядок): Унікальний ідентифікатор NFT
- `user_id` (рядок): ID власника NFT
- `chip_id` (рядок): Пов'язаний ідентифікатор мікросхеми
- `metadata_uri` (рядок): URI IPFS для метаданих NFT
- `owner` (рядок): Блокчейн-адреса власника

**Приклад**:
```json
{
  "nft_id": "nft_user_1_chip_quantum_1",
  "user_id": "user_1",
  "chip_id": "chip_quantum_1",
  "metadata_uri": "ipfs://metadata/nft_user_1_chip_quantum_1",
  "owner": "0x1234567890123456789012345678901234567890"
}
```

#### 6. Квести
**Шаблон ключа**: `quest:{quest_id}`

**Поля**:
- `quest_id` (рядок): Унікальний ідентифікатор квесту
- `user_id` (рядок): ID користувача, який виконує квест
- `title` (рядок): Назва квесту
- `description` (рядок): Опис квесту
- `status` (рядок): Статус квесту (active, completed)
- `reward` (рядок): Нагорода за виконання квесту
- `timestamp` (часова мітка ISO): Часова мітка створення

**Приклад**:
```json
{
  "quest_id": "quest_1",
  "user_id": "user_1",
  "title": "Quantum Chip Design",
  "description": "Design a quantum processor with 128 cores",
  "status": "completed",
  "reward": "nft_quantum_designer",
  "timestamp": "2025-09-29T10:30:00"
}
```

#### 7. Конфігурація системи
**Шаблон ключа**: `config:system`

**Поля**:
- `system` (об'єкт): Конфігурація на рівні системи
  - `version` (рядок): Версія системи
  - `mode` (рядок): Режим системи (production, development)
  - `maintenance` (булеве значення): Статус режиму обслуговування
- `subscription_price` (ціле число): Ціна підписки за замовчуванням
- `supported_fabs` (масив рядків): Список підтримуваних партнерів з виробництва
- `supported_protocols` (масив рядків): Список підтримуваних комунікаційних протоколів

**Приклад**:
```json
{
  "system": {
    "version": "11.0.0",
    "mode": "production",
    "maintenance": false
  },
  "subscription_price": 10,
  "supported_fabs": ["TSMC", "Intel", "Samsung"],
  "supported_protocols": ["MQTT", "OPC_UA"]
}
```

#### 8. Аналітика
**Шаблон ключа**: `analytics:metrics`

**Поля**:
- `chip_metrics` (об'єкт): Метрики продуктивності для мікросхем
  - `{chip_id}` (об'єкт): Метрики для конкретної мікросхеми
    - `performance` (float): Відсоток продуктивності
    - `efficiency` (float): Відсоток ефективності
    - `temperature` (float): Температура в градусах Цельсія
    - `last_updated` (часова мітка ISO): Часова мітка останнього оновлення

**Приклад**:
```json
{
  "chip_metrics": {
    "chip_quantum_1": {
      "performance": 95.5,
      "efficiency": 87.2,
      "temperature": 45.3,
      "last_updated": "2025-09-29T10:30:00"
    }
  }
}
```

### Лічильники
**Ключі**: Прості цілі значення, що використовуються для генерації унікальних ID

- `driver_counter`: Поточний лічильник ID драйверів
- `collab_counter`: Поточний лічильник ID співпраці
- `process_counter`: Поточний лічильник ID процесів
- `quest_counter`: Поточний лічильник ID квестів
- `nft_counter`: Поточний лічильник ID NFT

## Відносини

### Відносини користувачів
- Користувачі можуть створювати кілька драйверів, співпраць, процесів і квестів
- Користувачі можуть брати участь у співпраці як співавтори
- Користувачі можуть володіти кількома NFT

### Відносини мікросхем
- Мікросхеми пов'язані з драйверами, співпрацею, процесами та NFT
- Метрики мікросхем зберігаються в аналітичних даних

## Шаблони доступу до даних

### Операції читання
1. Отримати користувача за ID: `GET user:{user_id}`
2. Отримати всіх користувачів: `KEYS user:*`
3. Отримати драйвер за ID: `GET driver:{driver_id}`
4. Отримати всі драйвери: `KEYS driver:*`
5. Отримати співпрацю за ID: `GET collab:{collab_id}`
6. Отримати всю співпрацю: `KEYS collab:*`
7. Отримати процес за ID: `GET process:{process_id}`
8. Отримати всі процеси: `KEYS process:*`
9. Отримати NFT за ID: `GET nft:{nft_id}`
10. Отримати всі NFT: `KEYS nft:*`
11. Отримати квест за ID: `GET quest:{quest_id}`
12. Отримати всі квести: `KEYS quest:*`
13. Отримати конфігурацію системи: `GET config:system`
14. Отримати аналітичні дані: `GET analytics:metrics`

### Операції запису
1. Створити/оновити користувача: `SET user:{user_id} {user_data}`
2. Створити/оновити драйвер: `SET driver:{driver_id} {driver_data}`
3. Створити/оновити співпрацю: `SET collab:{collab_id} {collab_data}`
4. Створити/оновити процес: `SET process:{process_id} {process_data}`
5. Створити/оновити NFT: `SET nft:{nft_id} {nft_data}`
6. Створити/оновити квест: `SET quest:{quest_id} {quest_data}`
7. Оновити конфігурацію системи: `SET config:system {config_data}`
8. Оновити аналітичні дані: `SET analytics:metrics {analytics_data}`
9. Оновити лічильники: `SET {counter_name} {value}`

## Стратегія індексації
Ключі Redis служать основним індексом. Додаткова індексація досягається через:
1. Угоди про іменування ключів для групування пов'язаних даних
2. Механізми лічильників для генерації унікальних ID
3. Кешування на рівні додатку часто використовуваних даних

## Міркування щодо продуктивності
1. Усі дані зберігаються як рядки JSON для гнучкості
2. Ключі розроблено для ефективного зіставлення шаблонів за допомогою команди `KEYS`
3. Лічильники використовуються для уникнення дорогих операцій `KEYS` для генерації ID
4. Аналітичні дані оновлюються періодично для мінімізації операцій запису

## Резервне копіювання та відновлення
1. Регулярні знімки Redis за допомогою збереження RDB
2. Логування AOF (Append Only File) для надійності
3. Дані можна експортувати за допомогою команд `DUMP` та `RESTORE`
4. Скрипти демонстраційних даних забезпечують механізм відновлення для середовищ розробки

## Міркування щодо безпеки
1. Дані зберігаються у вигляді звичайного тексту JSON
2. Контроль доступу слід реалізувати на рівні додатку
3. Вразливі дані слід шифрувати перед зберіганням
4. Аутентифікацію Redis слід увімкнути в середовищах виробництва

## Масштабованість
1. Обмеження Redis з одним екземпляром для великих наборів даних
2. Стратегії шардування ключів для горизонтального масштабування
3. Розгляньте Redis Cluster для розгортань у виробництві
4. Розділення даних за користувачами або часом для кращої продуктивності

## Обслуговування
1. Регулярне очищення застарілих або непотрібних даних
2. Процедури скидання лічильників для середовищ розробки
3. Перевірка валідації та цілісності даних
4. Моніторинг і оптимізація продуктивності